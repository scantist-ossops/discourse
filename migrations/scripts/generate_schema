#!/usr/bin/env ruby
# frozen_string_literal: true

puts "Loading application..."
require_relative "../../config/environment"

module Migrations
  class GenerateSchema
    def initialize(opts = {})
      config = YAML.load_file(File.join(__dir__, "schema.yml"))

      @connection = ActiveRecord::Base.connection
      @output_stream = StringIO.new

      @output_directory = config["output_directory"]
      @output_filename = config["output_filename"]

      @table_configs = config["tables"]
      @column_configs = config["columns"]
    end

    def self.run
      puts "Generating base migration schema for Discourse #{Discourse::VERSION::STRING}"

      self.new.run

      puts "", "Done"
    end

    def run
      header
      tables
      save
    end

    private

    def header
      @output_stream.puts <<~HEADER
         /*
         This file is auto-generated from the current state of the Discourse core database schema. Instead
         of editing it directly, please update the `schema.yml` configuration file and re-run the
         `generate_schema` script to update it.
        */
      HEADER
    end

    def tables
      puts "Generating tables..."

      configured_table_names.each do |name|
        raise "Core table named '#{name}' not found" unless valid_table?(name)

        table(name)
      end
    end

    def generate_column(column)
      @output_stream.print "  #{column.name} #{type(column)}"
      @output_stream.print " NOT NULL" unless column.null
      @output_stream.puts ","
    end

    def generate_index(table_name, index)
      @output_stream.print "CREATE "
      @output_stream.print "UNIQUE " if index["unique"]
      @output_stream.puts "INDEX #{index["name"]} ON #{table_name} (#{index["columns"].join(", ")});"
    end

    def column_list_for(table_name)
      if @table_configs.dig(table_name, "ignore").present?
        [:ignore, column_ignore_list_for(table_name)]
      elsif @table_configs.dig(table_name, "include").present?
        [:include, column_include_list_for(table_name)]
      else
        []
      end
    end

    def table(name)
      puts "Generating #{name}..."

      column_records = columns(name)
      mode, column_list = column_list_for(name)
      indexes = indexes(name) # TODO: Allow core indexes to moved/ignored???'
      configured_primary_key = primary_key(name)

      primary_key, composite_key =
        if configured_primary_key.present?
          [configured_primary_key].flatten.each do |pk|
            if column_records.map(&:name).exclude?(pk)
              raise "Column named '#{pk}' does not exist in table '#{name}'"
            end
          end

          [
            configured_primary_key,
            configured_primary_key.is_a?(Array) && configured_primary_key.length > 1,
          ]
        else
          [@connection.primary_key(name), false]
        end

      @output_stream.puts ""
      @output_stream.puts "CREATE TABLE #{name} ("

      unless composite_key
        primary_key_column = column_records.find { |c| c.name == primary_key }

        @output_stream.puts "  #{primary_key_column.name} #{type(primary_key_column)} NOT NULL PRIMARY KEY,"
      end

      column_records.each do |column|
        next if global_column_ignore_list.include?(column.name)
        next if (mode == :ignore) && column_list.include?(column.name)
        if !column.is_a?(CustomColumn) && (mode == :include) && column_list.exclude?(column.name)
          next
        end
        next if !composite_key && (column.name == primary_key)

        generate_column(column)
      end

      @output_stream.puts "  PRIMARY KEY (#{primary_key.join(", ")})," if composite_key

      @output_stream.seek(@output_stream.pos - 2) # Remove last new line & trailing comma
      @output_stream.puts "\n);"

      @output_stream.puts "" if indexes.present?

      indexes.each { |index| generate_index(name, index) }
    end

    class CustomColumn
      attr_reader :name

      def initialize(name, type, null)
        @name = name
        @raw_type = type
        @raw_null = null
      end

      def type
        @raw_type&.to_sym || :text
      end

      def null
        @raw_null.nil? ? true : @raw_null
      end

      def merge!(other_column)
        @raw_null ||= other_column.null
        @raw_type ||= other_column.type

        self
      end
    end

    def columns(name)
      extensions = column_extensions(name)

      return extensions if virtual_table?(name)

      default_columns = @connection.columns(name)

      return default_columns if extensions.blank?

      extended_columns =
        default_columns.map do |default_column|
          extension = extensions.find { |ext| ext.name == default_column.name }

          if extension
            extensions.delete(extension)

            extension.merge!(default_column)
          else
            default_column
          end
        end

      extended_columns + extensions
    end

    def column_extensions(name)
      extensions = @table_configs.dig(name, "extend")

      return [] if extensions.nil?

      extensions.map { |column| CustomColumn.new(column["name"], column["type"], column["null"]) }
    end

    def type(column)
      case column.type
      when :string, :inet
        "TEXT"
      else
        column.type.upcase
      end
    end

    def valid_table?(name)
      @connection.tables.include?(name) || virtual_table?(name)
    end

    def virtual_table?(name)
      !!@table_configs.dig(name, "virtual")
    end

    def global_column_ignore_list
      @column_configs["ignore"] || []
    end

    def column_ignore_list_for(table_name)
      @table_configs.dig(table_name, "ignore") || []
    end

    def column_include_list_for(table_name)
      @table_configs.dig(table_name, "include") || []
    end

    def indexes(table_name)
      @table_configs.dig(table_name, "indexes") || []
    end

    def primary_key(table_name)
      @table_configs.dig(table_name, "primary_key")
    end

    def configured_table_names
      @configured_table_names ||= @table_configs&.keys&.sort || []
    end

    def save
      puts "Generating base schema file..."

      output_filename = File.join(__dir__, @output_directory, @output_filename)
      File.open(output_filename, "w") { |f| f << @output_stream.string.chomp }
    end
  end
end

Migrations::GenerateSchema.run
